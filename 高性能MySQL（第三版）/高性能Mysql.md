# MySQL 优化技巧

## 数据类型优化
- 尽可能使用存储数据的最小数据类型
- 选择简单的数据类型（整型比字符操作代价更低）
- 避免NULL值，查询包含NULL的列，MySQL难以优化，使得索引、索引统计更复杂。

#### 整数类型
有两种类型的数字：整数和实数。如果存储整数，可以使用这几种整数类型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。 分别使用 8,6, 24, 32, 64位存储空间。
*整数类型有UNSIGNED表示不允许负值*

#### 实数类型
FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。
DECIMAL类型用于存储精确的小数,允许最多65个数字,在计算中DECIMAL会转换为DOUBLE类型

#### 字符串类型
VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型 更节省空间，因为它仅使用必要的空间，*VARCHAR需要使用1 或2个额外字节记录字符串的长度：如果列的最大长度小于或 等于255 字节，则只使用1个字节表示，否则使用2个字节*
CHAR类型是定长的：MySQL总是根据定义的字符串 长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。
> 与 CHAR 和 VARCHAR 类似的类型还有 BINARY 和 VARBINARY, 它们存储的是二进制字符串。
BLOB和 TEXT都是为存储很大的数据而设计的字符串数据类型， 分别采用二进制和字符方式存储。

#### 时间和日期类型
DATETIME类型能保存大范围的值， 从1001年到9999年， 精度为秒。 它把日期和时间封装到格式为YYYY MMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。
TIMESTAMP类型保存了从1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME 小得多：只能表示从1970年到2038年。MySQL提供了FROM_ UNIXTIME()函数把Unix时间戳转换为日期，井提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。
> 除了特殊行为之外，通常也应该尽量使用TIMESTAMP, 因为它比DATETIME 空间效率更高。

## 索引优化
#### 索引类型
###### ***B-Tree索引***
使用B-Tree数据结构来存储数据.[B-tree]("https://baike.baidu.com/item/B-tree/6606402?fr=aladdin" "B-tree") 
B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。 
**可以使用B-Tree索引的查询类型**
B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。
- 全值匹配：全值匹配指的是和索引中的所有列进行匹配
- 匹配最左前缀：只使用索引的第一列
- 匹配列前缀：以只匹配某一列的值的开头部分。
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列：即第一列全匹配，第二列范围匹配。
- 只访问索引的查询：B-Tree通常可以支持 “只访问索引的查询”，即查询只需要访问索引，而无须访问数据行。 
> 如果不是按照索引的最左列开始查找，则无法使用索引。
> 不能跳过索引中的列。
> 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

##### ***哈希索引***
哈希索引(hashindex)基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hashcode), 哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时哈希表中保存指向每个数据行的指针。
如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。
- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的 影响并不明显。
- 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。 
- 哈希索引只支持等值比较查询，包括＝、IN()、<=、>=。也不支持任何范围查询
- 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。
> InnoDB引擎有一个特殊的功能叫做 “自适应哈希索引(adaptivehash index)"。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。 这是一个完全自动的、 内部的行为，用户无法控制或者配置，不过如果有 必要，完全可以关闭该功能。

##### 空间数据索引
这类索引无须前缀查询。 空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。 

##### 全文索引
是一种种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。
全文搜索和其他几类索引的匹配方式完全不一样，它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情， 而不是简单的WHERE条件匹配。
在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突， 全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

#### 高性能索引策略
1. 索引字段策略
如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。
简单来说就是 索引列不能使用函数、计算、表达式，会导致索引无效。
2. 前缀索引
有时候需要索引很长的字符列， 这会让索引变得大且慢。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。
要选择足够长的的前缀保证较高的准确性。
前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和 GROUP BY,也无法使用前缀索引做覆盖扫描。
3. 多列索引
通常不要为每一列建立索引，要按照正确的顺序建立多列索引。
  - 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
  - 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存、 排序和合并操作上。可以尝试将查询改写成UNION的方式往往更好。
如果在EXPLA IN中看到有索引合井，应该好好检查一下查询和表的结构，看是不是已经是最优的。也可以通过参数optimizer_switch来关闭索引合并功能。也可以使用IGNORE INDEX提示让优化器忽略掉某些索引。
4. 索引列顺序
正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。（仅适用于B-Tree索引，哈希或者其他类型的索引并不会按顺序存储数据）
5. 覆盖索引
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引” 。
覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。
6. 冗余和重复索引
重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。 
如果创建了索引(A, B)再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当作索引(A)来使用（这种冗余只是对B-Tree索引来说的）。但是如果再创建索引，(B,A)，则不是冗余索引，索引(B)
也不是，因为B不是索引(A, B)的最左前缀列。

#### 查询性能优化

##### 查询执行的步骤
1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存， 如果命中了缓存， 则立刻返回存储在缓存中的结果。 否则进入下一阶段。
3. 服务器端进行SQL解析、 预处理， 再由优化器生成对应的执行计划。
4. MySQL根据优化器生成

##### 查询状态
查看当前的状态,执行SQL SHOW FULL PROCESSLIST
- Sleep: 线程正在等待客户端发送新的请求
- Query: 线程正在执行查询 或者正在将结果发送给客户端
- Locked: 在MySQL服务器层，该线程正在等待表锁
- Analyzing and statistics: 线程正在收集存储引擎的统计信息，井生成查询的执行计划
- Sorting result: 线程正在对结果集进行排序
- Sending data: 线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据

> 查询缓存: 在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据


##### 优化数据访问
1. 查询不需要的记录
  查询结果行中不需要的记录行不要查询出来，使用LIMIT进行限制.
2. 多表关联时返回全部列
"SELECT * " 查询全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的IO、内存和CPU的消耗。这样做有时候还能避免某些列被修改带来的问题。有时候查询返回超过需要的数据可以简化开发，提高代码可用性，从中进行取舍。
3. 重复查询相同的数据
当出现这种情况使用缓存解决。

##### 是否在扫描额外的记录 
衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数。

##### 重构查询的方式
1. 将一个复杂查询拆分成多个简单查询
2. 对关联查询进行分解，然后结果在应用程序中进行关联
  - 高效利用缓存
  - 减少查询对锁的竞争
  - 更容易对数据库拆分，高可用、可拓展。
  - 程序中使用Hash关联，某些场景效率相比Mysql的嵌套关联效率更高

## 索引使用
MySQL QUERY CACHE

查询缓存可以将查询语句结构和查询结果缓存起来。如果查询是同样结构的SQL,可以直接从缓存中读取结果。表中任何数据或是结构的改变，缓存就会失效。

缓存内容为 SELECT 的结果集, 缓存使用完整的 SQL 字符串做 KEY, 并区分大小写，空格等。即两个 SQL 必须完全一致才会缓存命中。

MySQL QUERY CACHE 是对大小写敏感的，因为Query Cache在内存中是以HASH结构来进行映射。

对于频繁更新的表，缓存会频繁失效给服务器造成很大的开销

开启缓存: 到MySQL安装目录下找到my.ini文件修改，linux下是my.cnf。 文件目录C:\ProgramData\MySQL\MySQL Server

查看缓存 show status like '%qcache%';
  - Qcache_free_blocks: 表示查询缓存中目前还有多少剩余的blocks。值较大，说明查询缓存中的内存碎片过多。  
    减少碎片: 合适的 query_cache_min_res_unit 可以减少碎片，这个参数最合适的大小和应用程序查询结果的平均大小直接相关，可以通过内存实际消耗(query_cache_size - Qcache_free_memory)除以 Qcache_queries_in_cache 计算平均缓存大小。 
  - Qcache_free_memory: 查询缓存的剩余内存大小。 
  - Qcache_hits: 表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。 
  - Qcache_inserts: 表示多少次未命中然后插入。 
  - Qcache_lowmem_prunes: 该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，可以适当的调整缓存大小。 
  - Qcache_not_cached: 表示因为 query_cache_type 的设置而没有被缓存的查询数量。 
  - Qcache_queries_in_cache: 当前缓存中缓存的查询数量。 
  - Qcache_total_blocks:当前缓存的block数量。

查询缓存状态 SHOW VARIABLES LIKE '%query_cache%';
  - have_query_cache 是否支持缓存
  - query_cache_limit 允许缓存的单条查询结果集的最大容量
  - query_cache_min_res_unit 分配内存块时的最小单位大小
  - query_cache_size  缓存使用的总内存空间大小
  - query_cache_type 缓存类型
    - OFF(0) 未开启
    - NO(1) 开启
    - DEMAND(2) 只有当SELECT语句中使用了SQL_CACHE才开启
     使用方法: SELECT SQL_CACHE * FROM my_table WHERE condition;

设置缓存变量: set global query_cache_size = 600000;
清空缓存 reset query cache;
整理碎片 flush query cache
查询缓存结果集 show status like 'qcache_q%'

> 使用MySQL QUERY CACHE时，尽量将query_cache_type设置为2。 如果开启全部缓存，所有SQL都会产生缓存，每次执行SQL都会先去缓存中找结果，频繁的I/O会导致效率的降低。应该结合业务找到适合缓存的SQL进行缓存。















> ***文章内容从《高性能MySQL》摘选***